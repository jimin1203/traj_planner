import numpy as np
import math


def calc_splines(path: np.ndarray, # x, y좌표로 구성된 경로
                 el_lengths: np.ndarray = None, # 각 점 간의 거리
                 psi_s: float = None, # 시작점의 heading 각도
                 psi_e: float = None, # 끝점의 heading 각도
                 use_dist_scaling: bool = True) -> tuple: # 각 구간의 거리 차이를 고려하여 heading과 curvature 조정.
    """
    author:
    Tim Stahl & Alexander Heilmeier

    .. description::
    Solve for curvature continuous cubic splines (spline parameter t) between given points i (splines evaluated at
    t = 0 and t = 1). The splines must be set up separately for x- and y-coordinate.

    Spline equations:
    P_{x,y}(t)   =  a_3 * t³ +  a_2 * t² + a_1 * t + a_0
    P_{x,y}'(t)  = 3a_3 * t² + 2a_2 * t  + a_1
    P_{x,y}''(t) = 6a_3 * t  + 2a_2

    a * {x; y} = {b_x; b_y}

    .. inputs::
    :param path:                x and y coordinates as the basis for the spline construction (closed or unclosed). If
                                path is provided unclosed, headings psi_s and psi_e are required!
    :type path:                 np.ndarray
    :param el_lengths:          distances between path points (closed or unclosed). The input is optional. The distances
                                are required for the scaling of heading and curvature values. They are calculated using
                                euclidian distances if required but not supplied.
    :type el_lengths:           np.ndarray
    :param psi_s:               orientation of the {start, end} point.
    :type psi_s:                float
    :param psi_e:               orientation of the {start, end} point.
    :type psi_e:                float
    :param use_dist_scaling:    bool flag to indicate if heading and curvature scaling should be performed. This should
                                be done if the distances between the points in the path are not equal.
    :type use_dist_scaling:     bool

    .. outputs::
    :return x_coeff:            spline coefficients of the x-component.
    :rtype x_coeff:             np.ndarray
    :return y_coeff:            spline coefficients of the y-component.
    :rtype y_coeff:             np.ndarray
    :return M:                  LES coefficients.
    :rtype M:                   np.ndarray
    :return normvec_normalized: normalized normal vectors [x, y].
    :rtype normvec_normalized:  np.ndarray

    .. notes::
    Outputs are always unclosed!

    path and el_lengths inputs can either be closed or unclosed, but must be consistent! The function detects
    automatically if the path was inserted closed.

    Coefficient matrices have the form a_0i, a_1i * t, a_2i * t^2, a_3i * t^3.
    """

    # check if path is closed
    if np.all(np.isclose(path[0], path[-1])) and psi_s is None:
        closed = True
    else:
        closed = False

    # check inputs
    if not closed and (psi_s is None or psi_e is None):
        raise RuntimeError("Headings must be provided for unclosed spline calculation!")

    if el_lengths is not None and path.shape[0] != el_lengths.size + 1:
        raise RuntimeError("el_lengths input must be one element smaller than path input!")

    # if distances between path coordinates are not provided but required, calculate euclidean distances as el_lengths
    if use_dist_scaling and el_lengths is None:
        el_lengths = np.sqrt(np.sum(np.power(np.diff(path, axis=0), 2), axis=1)) # 점들 간의 차이 계산해서 제곱한 후 제곱근 구하기 -> 유클리드 거리 계산.
    elif el_lengths is not None:
        el_lengths = np.copy(el_lengths)

    # if closed and use_dist_scaling active append element length in order to obtain overlapping elements for proper
    # scaling of the last element afterwards
    if use_dist_scaling and closed: # 경로가 닫혀 있을 때, 마지막 구간의 거리를 추가해줌으로써 마지막 구간이 첫번째 점과 연결될 수 있도록 한다.
        el_lengths = np.append(el_lengths, el_lengths[0])

    # get number of splines
    no_splines = path.shape[0] - 1

    # calculate scaling factors between every pair of splines
    if use_dist_scaling:
        scaling = el_lengths[:-1] / el_lengths[1:]
        # el_lengths[:-1]: 마지막 요소 제외한 리스트
        # el_lengths[1:]: 첫 번째 요소 제외한 리스트트
    else:
        scaling = np.ones(no_splines - 1)

    # ------------------------------------------------------------------------------------------------------------------
    # DEFINE LINEAR EQUATION SYSTEM ------------------------------------------------------------------------------------
    # ------------------------------------------------------------------------------------------------------------------

    # M_{x,y} * a_{x,y} = b_{x,y}) with a_{x,y} being the desired spline param
    # *4 because of 4 parameters in cubic spline
    # 각 spline 구간마다 4개의 제약조건 발생(한 spline당 행 4개씩 있는 이유)
    # 각 spline 구간마다 4개의 계수가 있으므로 한 행마다 4개의 열 발생생
    M = np.zeros((no_splines * 4, no_splines * 4)) # 각 spline당 제약조건 4개
    b_x = np.zeros((no_splines * 4, 1)) # spline의 시작점과 끝점을 설명
    b_y = np.zeros((no_splines * 4, 1))

    # create template for M array entries(하나의 spline마다 적용되는 제약 조건)
    # row 1: beginning of current spline should be placed on current point (t = 0)
    # row 2: end of current spline should be placed on next point (t = 1)
    # row 3: heading at end of current spline should be equal to heading at beginning of next spline (t = 1 and t = 0)
    # row 4: curvature at end of current spline should be equal to curvature at beginning of next spline (t = 1 and
    #        t = 0)
    template_M = np.array(                          # current point               | next point              | bounds
                [[1,  0,  0,  0,  0,  0,  0,  0],   # a_0i                                                  = {x,y}_i
                 [1,  1,  1,  1,  0,  0,  0,  0],   # a_0i + a_1i +  a_2i +  a_3i                           = {x,y}_i+1
                 [0,  1,  2,  3,  0, -1,  0,  0],   # _      a_1i + 2a_2i + 3a_3i      - a_1i+1             = 0
                 [0,  0,  2,  6,  0,  0, -2,  0]])  # _             2a_2i + 6a_3i               - 2a_2i+1   = 0

    for i in range(no_splines): # 현재 스플라인의 인덱스
        j = i * 4 # 현재 스플라인의 행렬 M에서 시작 위치

        if i < no_splines - 1: # 마지막 스플라인이 아닌 경우
            M[j: j + 4, j: j + 8] = template_M # 현재 spline의 4개 조건을 M 행렬에 추가가
            # print(scaling[i])
            M[j + 2, j + 5] *= scaling[i] # heading 조건에 scaling 적용
            M[j + 3, j + 6] *= math.pow(scaling[i], 2) # curvature 조건에 scaling 적용

        else: # 마지막 스플라인의 경우
            # no curvature and heading bounds on last element (handled afterwards)
            M[j: j + 2, j: j + 4] = [[1,  0,  0,  0], # 마지막 spline에서는 heading과 curvature 조건 적용x
                                     [1,  1,  1,  1]] # 시작점과 끝점 조건만 추가

        b_x[j: j + 2] = [[path[i,     0]],
                         [path[i + 1, 0]]]
        # print(f"b_x1: {b_x}\n")
        b_y[j: j + 2] = [[path[i,     1]],
                         [path[i + 1, 1]]]

    # ------------------------------------------------------------------------------------------------------------------
    # SET BOUNDARY CONDITIONS FOR LAST AND FIRST POINT -----------------------------------------------------------------
    # ------------------------------------------------------------------------------------------------------------------

    # 시작점과 끝점에서의 heading 고정-> 자연스럽게 이어지도록 보장
    # 곡률은 스플라인이 연결될 때 연속성 가지니까, heading 고정하여 경계조건 설정
    if not closed:
        # if the path is unclosed we want to fix heading at the start and end point of the path (curvature cannot be
        # determined in this case) -> set heading boundary conditions

        # heading start point
        # 끝에서 2번째 행 고정
        M[-2, 1] = 1  # heading start point (evaluated at t = 0)

        if el_lengths is None:
            el_length_s = 1.0
        else:
            el_length_s = el_lengths[0]
        # print(f"el_length_s: {el_length_s}\n")
        
        # psi_s: 시작점에서의 heading 각도
        # x축, y축으로 분해항 각각 b_x와 b_y에 저장하여 벡터의 방향 나타냄.
        # print(f"b_x[-2]의 math.cos(psi_s + math.pi / 2)값 {math.cos(psi_s + math.pi / 2)}\n")
        b_x[-2] = math.cos(psi_s + math.pi / 2) * el_length_s
        b_y[-2] = math.sin(psi_s + math.pi / 2) * el_length_s

        # 행렬 M의 마지막 행을 사용하여 끝점에서의 heading 고정
        # heading end point
        M[-1, -4:] = [0, 1, 2, 3]  # heading end point (evaluated at t = 1)

        if el_lengths is None:
            el_length_e = 1.0
        else:
            el_length_e = el_lengths[-1]
        # print(f"el_length_e: {el_length_e}\n")
        # print(f"{psi_e}\n")
        # print(f"b_x[-1]의 math.cos(psi_e + math.pi / 2)값 {math.cos(psi_e + math.pi / 2)}\n")
        # heading은 벡터의 방향을 나타내므로, 이를 x-축, y-축으로 분해.
        b_x[-1] = math.cos(psi_e + math.pi / 2) * el_length_e
        b_y[-1] = math.sin(psi_e + math.pi / 2) * el_length_e
        # print(f"b_x: {b_x}\n")
    else:
        # heading boundary condition (for a closed spline)
        M[-2, 1] = scaling[-1] # 마지막 구간의 scaling 값 곱하여 heading 조정
        M[-2, -3:] = [-1, -2, -3] # 마지막 구간의 heading 계수 활성화
        # b_x[-2] = 0
        # b_y[-2] = 0

        # curvature boundary condition (for a closed spline)
        M[-1, 2] = 2 * math.pow(scaling[-1], 2)
        M[-1, -2:] = [-2, -6]
        # b_x[-1] = 0
        # b_y[-1] = 0

    # ------------------------------------------------------------------------------------------------------------------
    # SOLVE ------------------------------------------------------------------------------------------------------------
    # ------------------------------------------------------------------------------------------------------------------
    # M*a=b를 풀어서 spline 계수를 계산.
    # 결과를 spline 구간별로 재구성.
    x_les = np.squeeze(np.linalg.solve(M, b_x))  # squeeze removes single-dimensional entries
    # print(f"resultM: {M}\n")
    # print(f"b_x: {b_x}\n")
    
    # print(f"x_les: {x_les}\n")
    y_les = np.squeeze(np.linalg.solve(M, b_y))

    # get coefficients of every piece into one row -> reshape
    coeffs_x = np.reshape(x_les, (no_splines, 4)) # spline 구간의 x, y 계수
    coeffs_y = np.reshape(y_les, (no_splines, 4)) # 구조 : n개의 스플라인, 각 스플라인의 계수 4개개

    # 법선 벡터 계산
    # get normal vector (behind used here instead of ahead for consistency with other functions) (second coefficient of
    # cubic splines is relevant for the heading)
    normvec = np.stack((coeffs_y[:, 1], -coeffs_x[:, 1]), axis=1)

    # normalize normal vectors
    norm_factors = 1.0 / np.sqrt(np.sum(np.power(normvec, 2), axis=1))
    normvec_normalized = np.expand_dims(norm_factors, axis=1) * normvec

    return coeffs_x, coeffs_y, M, normvec_normalized
    # spline 구간의 x, y 계수, 선형 방정식의 계수 행렬, 정규화된 법선 벡터.

# testing --------------------------------------------------------------------------------------------------------------
if __name__ == "__main__": # import될때는 실행안되고 직접 실행할때만 실행.
    import os
    import sys
    import matplotlib.pyplot as plt
    sys.path.append(os.path.dirname(__file__))
    from interp_splines import interp_splines
    # 경로 데이터 임의 지정.
    path_coords = np.array([[50.0, 10.0], [10.0, 4.0], [0.0, 0.0]])
    psi_s_ = np.pi / 2.0 # 시작점과 끝점에서의 heading 기울기 지정.
    psi_e_ = np.pi / 1.3
    coeffs_x_, coeffs_y_ = calc_splines(path=path_coords,
                                        psi_s=psi_s_,
                                        psi_e=psi_e_)[0:2]

    path_interp = interp_splines(coeffs_x=coeffs_x_,
                                 coeffs_y=coeffs_y_,
                                 incl_last_point=True,
                                 stepsize_approx=0.5)[0]

    # print(f"시작점: {path_interp[0]}, 끝점: {path_interp[1]}")
    # calc_splines에서 계산한 계수로 interp_splines 적용하는 것
    print(f"1.coeffs_x {coeffs_x_}\n2.coeffs_y{coeffs_y_}")
    plt.plot(path_interp[:, 0], path_interp[:, 1], label="Spline Path")
    plt.scatter(path_coords[:, 0], path_coords[:, 1], color="red", label="Waypoints")
    plt.axis('equal')
    # plt.show()